<!DOCTYPE html><html lang="zh-Hans"><head><meta name="generator" content="Hexo 3.9.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="基于Tesseract的简易身份证OCR"><meta name="keywords" content="Magolor,图像处理,OCR,Tesseract,OCR,身份证,基于Tesseract的简易身份证OCR"><meta name="author" content="Magolor"><meta name="copyright" content="Magolor"><title>基于Tesseract的简易身份证OCR | Magolor</title><link rel="shortcut icon" href="/Magolor-OC-trans-avatar-rd-64.ico"><link rel="stylesheet" href="/css/index.css?version=1.7.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.7.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css"><script src="https://cdn.jsdelivr.net/gh/upupming/gitalk@36368e5dffd049e956cdbbd751ff96c28d8255cf/dist/gitalk.min.js"></script><script src="https://cdn.jsdelivr.net/npm/blueimp-md5@2.10.0/js/md5.min.js"></script><link rel="dns-prefetch" href="https://hm.baidu.com"><script><!-- hexo-inject:begin --><!-- hexo-inject:end -->var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?cb418bedbb9a29dbb6d61e55c68bccc5";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();</script><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容:${query}"}},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  }
} </script><!-- hexo-inject:begin --><!-- hexo-inject:end --></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="切换文章详情">切换站点概览</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#了解tesseract"><span class="toc-text"> 了解Tesseract</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#数据格式说明"><span class="toc-text"> 数据格式说明</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#规整身份证照片ocr"><span class="toc-text"> 规整身份证照片OCR</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#工具"><span class="toc-text"> 工具</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#识别"><span class="toc-text"> 识别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#了解身份证"><span class="toc-text"> 了解身份证</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#其他角度身份证照片ocr"><span class="toc-text"> 其他角度身份证照片OCR</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#进一步预处理"><span class="toc-text"> 进一步预处理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#边缘检测"><span class="toc-text"> 边缘检测</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#矩形包围盒"><span class="toc-text"> 矩形包围盒</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#mix"><span class="toc-text"> Mix!</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#仿射变换和透视变换"><span class="toc-text"> 仿射变换和透视变换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#了解身份证-2"><span class="toc-text"> 了解身份证 · 2</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#完整代码"><span class="toc-text"> 完整代码</span></a></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="/img/Magolor-OC-trans-avatar.png"></div><div class="author-info__name text-center">Magolor</div><div class="author-info__description text-center">AFO的OIer；AI专业在读；业余作曲 (b站网易云Talirian)；业余科幻小说创作；科技至上主义者；蜂巢意识形态</div><div class="follow-button"><a href="https://magolor.cn/2018/07/22/2018-07-22-blog-01/">博主简介</a></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">42</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">标签</span><span class="pull-right">46</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">分类</span><span class="pull-right">12</span></a></div><hr><div class="author-info-links"><div class="author-info-links__title text-center">友链</div><a class="author-info-links__name text-center" href="https://rqy.moe" rel="external nofollow noopener noreferrer" target="_blank">_rqy</a><a class="author-info-links__name text-center" href="https://blog.csdn.net/wxh010910" rel="external nofollow noopener noreferrer" target="_blank">wxh010910</a><a class="author-info-links__name text-center" href="https://www.cnblogs.com/GXZlegend" rel="external nofollow noopener noreferrer" target="_blank">GXZlegend</a><a class="author-info-links__name text-center" href="https://www.cnblogs.com/RabbitHu" rel="external nofollow noopener noreferrer" target="_blank">RabbitHu</a><a class="author-info-links__name text-center" href="https://crazyinventor494388371.wordpress.com" rel="external nofollow noopener noreferrer" target="_blank">Vision</a><a class="author-info-links__name text-center" href="https://blog.xehoth.cc" rel="external nofollow noopener noreferrer" target="_blank">xehoth</a><a class="author-info-links__name text-center" href="https://blog.csdn.net/mys_c_k" rel="external nofollow noopener noreferrer" target="_blank">Mys_C_K</a><a class="author-info-links__name text-center" href="https://www.cnblogs.com/suncongbo" rel="external nofollow noopener noreferrer" target="_blank">suncongbo</a><a class="author-info-links__name text-center" href="https://www.cnblogs.com/Tian-Xing-Sakura" rel="external nofollow noopener noreferrer" target="_blank">Tian Xing</a><a class="author-info-links__name text-center" href="https://www.cnblogs.com/mlystdcall" rel="external nofollow noopener noreferrer" target="_blank">__stdcall</a><a class="author-info-links__name text-center" href="https://cydiater.me" rel="external nofollow noopener noreferrer" target="_blank">Cydiater</a><a class="author-info-links__name text-center" href="https://blog.csdn.net/icefox_zhx" rel="external nofollow noopener noreferrer" target="_blank">icefox</a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(/img/Beneath_the_Starlight_16-9.png)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">Magolor</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">首页</a><a class="site-page" href="/archives">文章</a><a class="site-page" href="/slides">幻灯片</a><a class="site-page" href="/categories">归档</a><a class="site-page" href="/tags">标签</a></span><span class="pull-right"><a class="site-page social-icon search"><i class="fa fa-search"></i><span> 搜索</span></a></span></div><div id="post-info"><div id="post-title">基于Tesseract的简易身份证OCR</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-02-13</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/其他/">其他</a><div class="post-meta-wordcount"><span>字数总计: </span><span class="word-count">8.3k</span><span class="post-meta__separator">|</span><span>阅读时长: 36 分钟</span></div></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><p>利用谷歌提供的<a href="https://github.com/tesseract-ocr/tesseract" rel="external nofollow noopener noreferrer" target="_blank">Tesseract开源OCR工具</a>来实现一个准确率一般的、简易的身份证信息提取工具。</p>
<!-- hexo-inject:begin --><!-- hexo-inject:end --><a id="more"></a>
<h2 id="了解tesseract"><a class="markdownIt-Anchor" href="#了解tesseract"></a> 了解Tesseract</h2>
<p>Tesseract是谷歌提供的一个开源OCR(Optical Character Recognition, 光学字符识别)工具，可以从图片中提取字符。支持英语、中文(简体/繁体以及横式/竖式)、数学公式以及上百种语言。其对于英文和数字的识别准确率比较高，但是对中文字符的识别准确率相对较低。</p>
<p>可以从Tesseract的Github仓库直接下载使用，也可以安装python的模块<code>pytesseract</code>，一种更加方便的方式是直接下载自动安装程序。本文使用<code>tesseract-ocr-w64-setup-v4.0.0.exe</code>，资源可以很容易在网络上找到并下载，这里就不再给出。</p>
<p><img src="/img/2020-02-13-blog-01/tesseract.png" alt="tesseract-ocr-w64-setup-v4.0.0.exe 安装界面"></p>
<p>安装时可以根据需要在<code>Additional script data</code>和<code>Additional language data</code>中安装对应的语言包，或者使用其他地方下载得到的语言包。安装完成后，使用前可能需要配置环境变量:</p>
<p><img src="/img/2020-02-13-blog-01/path.png" alt="配置环境变量TESSDATA_PREFIX"></p>
<p>然后在安装路径(如上图，默认为<code>C:\Program Files (x86)\Tesseract-OCR\</code>)中运行命令行，使用<code>tesseract [-l package] xxx.jpg yyy</code>来进行一次图片识别，其中<code>-l package</code>表示使用哪个语言包，不写则默认为<code>-l eng</code>；<code>xxx.jpg</code>是图片名称，<code>.png</code>等其他图片类型也可；<code>yyy</code>是输出结果文件，输出到<code>yyy.txt</code>。</p>
<br>
<h2 id="数据格式说明"><a class="markdownIt-Anchor" href="#数据格式说明"></a> 数据格式说明</h2>
<p>为了方便扩展，支持更多种类证件识别，可以对每种证件提前做好配置文件。本文用<code>.json</code>文件:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"sf"</span>:</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">"ratio"</span>: <span class="number">1.5851851851851851851851851851852</span>,</span><br><span class="line">        <span class="attr">"info"</span>:</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">"Eid"</span>: [<span class="number">0.3253</span>,<span class="number">0.8185</span>,<span class="number">0.8842</span>,<span class="number">0.9185</span>],</span><br><span class="line">            <span class="attr">"Zname"</span>: [<span class="number">0.1700</span>,<span class="number">0.1200</span>,<span class="number">0.3276</span>,<span class="number">0.2241</span>],</span><br><span class="line">            <span class="attr">"Zaddress"</span>: [<span class="number">0.1723</span>,<span class="number">0.5148</span>,<span class="number">0.6065</span>,<span class="number">0.7583</span>],</span><br><span class="line">            <span class="attr">"Mpicture"</span>: [<span class="number">0.5982</span>,<span class="number">0.1481</span>,<span class="number">0.9400</span>,<span class="number">0.7593</span>]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上述文件为例，<code>&quot;sf&quot;</code>就是一类证件种类(这里是身份证)，每种证件需要有信息<code>&quot;ratio&quot;</code>表示这种证件的长宽比，<code>&quot;info&quot;</code>表示证件中要识别的信息所在的相对位置。<code>&quot;info&quot;</code>这一项大大降低了识别难度，提高了识别准确率，不过也成为一项局限。需要人手动输入所有信息在图片中的相对位置<code>[x1,y1,x2,y2]</code>，图片左上角视为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><mn>0</mn><mo separator="true">,</mo><mn>0</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(0,0)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">0</span><span class="mclose">)</span></span></span></span>，右下角视为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><mn>1</mn><mo separator="true">,</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(1,1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span>。信息名称第一个字母表示种类，<code>E</code>为英文，<code>Z</code>为中文，<code>N</code>为数字(身份证号不用数字因为最后一位可能是<code>X</code>)，<code>M</code>表示只切割照片不识别文字。</p>
<p>图片的命名格式为<code>sfxxxxx.jpg</code>或<code>.png</code>，保证图片的前两位为证件种类名称。</p>
<br>
<h2 id="规整身份证照片ocr"><a class="markdownIt-Anchor" href="#规整身份证照片ocr"></a> 规整身份证照片OCR</h2>
<p>首先尝试对<strong>规整的身份证照片</strong>(完全对正并且身份证边界就是照片边界)进行识别。<strong>首先只提取身份证号以及家庭住址</strong>。</p>
<p><img src="/img/2020-02-13-blog-01/sf1.png" alt="本人身份证作为样例"></p>
<br>
<h3 id="工具"><a class="markdownIt-Anchor" href="#工具"></a> 工具</h3>
<p>首先定义一些有用的工具例如基本文件操作:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># utils.py</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> shutil</span><br><span class="line"><span class="keyword">import</span> string</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">clear</span><span class="params">(PATH)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> os.path.exists(PATH):</span><br><span class="line">        shutil.rmtree(PATH)</span><br><span class="line">    os.mkdir(PATH)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">read_json</span><span class="params">(FILE)</span>:</span></span><br><span class="line">    <span class="keyword">with</span> open(FILE,encoding=<span class="string">'utf-8'</span>) <span class="keyword">as</span> f:</span><br><span class="line">        data = json.loads(f.read())</span><br><span class="line">    <span class="keyword">return</span> data</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">save_json</span><span class="params">(object,FILE)</span>:</span></span><br><span class="line">    <span class="keyword">with</span> open(FILE,<span class="string">"w"</span>) <span class="keyword">as</span> f:</span><br><span class="line">        json.dump(object,f,ensure_ascii=<span class="literal">False</span>,sort_keys=<span class="literal">True</span>,indent=<span class="number">4</span>)</span><br></pre></td></tr></table></figure>
<br>
<h3 id="识别"><a class="markdownIt-Anchor" href="#识别"></a> 识别</h3>
<p>首先做好环境的准备: <code>src</code>为图片存放目录，<code>tmp</code>为工作用临时目录，<code>rst</code>为输出结果所在目录，为方便起见可以选择<code>dst</code>目录，使得<code>src</code>中识别完成的图片会移动到<code>dst</code>中。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># OCR.py</span></span><br><span class="line"><span class="keyword">from</span> copy <span class="keyword">import</span> deepcopy</span><br><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> imutils</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> preprocess <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">src = <span class="string">"images/"</span></span><br><span class="line">tmp = <span class="string">"temp/"</span></span><br><span class="line">dst = <span class="string">"processed/"</span></span><br><span class="line">rst = <span class="string">"results/"</span></span><br><span class="line">CHINESE = (</span><br><span class="line">          <span class="comment"># "chi_sim_2412"</span></span><br><span class="line">          <span class="comment"># "chi_sim_12771"</span></span><br><span class="line">           <span class="string">"chi_sim_43327"</span></span><br><span class="line">          )</span><br><span class="line">LAN = &#123;<span class="string">'Z'</span>:<span class="string">"-l "</span>+CHINESE,<span class="string">'N'</span>:<span class="string">""</span>,<span class="string">'E'</span>:<span class="string">""</span>&#125;</span><br><span class="line">config = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">make_environment</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">global</span> config</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(src):</span><br><span class="line">        os.mkdir(src)</span><br><span class="line">    clear(tmp)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(dst):</span><br><span class="line">        os.mkdir(dst)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(rst):</span><br><span class="line">        os.mkdir(rst)</span><br><span class="line">    config = read_json(<span class="string">"config.json"</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">tesseract</span><span class="params">(FILE,TYPE,RESULT)</span>:</span></span><br><span class="line">    command = <span class="string">'tesseract &#123;0&#125; &#123;1&#125; &#123;2&#125;'</span>.format(LAN[TYPE],FILE,RESULT)</span><br><span class="line">    <span class="keyword">return</span> subprocess.Popen(command,shell=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>
<p><code>chi_sim</code>为中文语言包名称，本文尝试了多个语言包，用其文件大小作为区分。</p>
<p>接下来定义和实现图像识别的函数:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># OCR.py</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">OCR</span><span class="params">(PIC_NAME,move=False,delete=False)</span></span></span><br></pre></td></tr></table></figure>
<p><code>PIC_NAME</code>为照片名称(带后缀)，<code>move=True</code>表示识别完成后将图片<strong>复制</strong>到<code>dst</code>目录，<code>delete=True</code>表示识别完成后将<code>src</code>目录的图片删除。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># OCR.py</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">OCR</span><span class="params">(PIC_NAME,move=False,delete=False)</span>:</span></span><br><span class="line">    PATH = src+PIC_NAME</span><br><span class="line">    category = (deepcopy(config[PIC_NAME[:<span class="number">2</span>]]) <span class="keyword">if</span> PIC_NAME[:<span class="number">2</span>] <span class="keyword">in</span> config <span class="keyword">else</span> &#123;<span class="string">'info'</span>:&#123;<span class="string">'Z0'</span>:[<span class="number">0.</span>,<span class="number">0.</span>,<span class="number">1.</span>,<span class="number">1.</span>]&#125;&#125;)[<span class="string">'info'</span>]</span><br><span class="line">    result = &#123;&#125;</span><br><span class="line">    thread = &#123;&#125;</span><br><span class="line">    <span class="keyword">with</span> Image.open(PATH) <span class="keyword">as</span> img:</span><br><span class="line">        w,h = img.size</span><br><span class="line">        <span class="keyword">for</span> key,box <span class="keyword">in</span> category.items():</span><br><span class="line">            TEMP = tmp+key+<span class="string">"_"</span>+PIC_NAME</span><br><span class="line">            RESULT = tmp+key+<span class="string">"_"</span>+PIC_NAME.split(<span class="string">'.'</span>)[<span class="number">0</span>]</span><br><span class="line">            box[<span class="number">0</span>] *= w; box[<span class="number">1</span>] *= h; box[<span class="number">2</span>] *= w; box[<span class="number">3</span>] *= h</span><br><span class="line">            img_cr = img.crop([int(round(j)) <span class="keyword">for</span> j <span class="keyword">in</span> box])</span><br><span class="line">            <span class="comment"># img_cr.show()</span></span><br><span class="line">            img_cr = normalized(img_cr)</span><br><span class="line">            img_cr.save(TEMP,dpi=(<span class="number">300.0</span>,<span class="number">300.0</span>))</span><br><span class="line">            thread[key] = tesseract(TEMP,key[<span class="number">0</span>],RESULT)</span><br><span class="line">        <span class="keyword">for</span> key,box <span class="keyword">in</span> category.items():</span><br><span class="line">            TEMP = tmp+key+<span class="string">"_"</span>+PIC_NAME</span><br><span class="line">            RESULT = tmp+key+<span class="string">"_"</span>+PIC_NAME.split(<span class="string">'.'</span>)[<span class="number">0</span>]+<span class="string">".txt"</span></span><br><span class="line">            thread[key].wait()</span><br><span class="line">            <span class="keyword">with</span> open(RESULT,<span class="string">"r"</span>,encoding=<span class="string">'UTF-8'</span>) <span class="keyword">as</span> f:</span><br><span class="line">                result[key] = clean(f.read())</span><br><span class="line">    <span class="keyword">if</span> move:</span><br><span class="line">        <span class="keyword">with</span> Image.open(PATH) <span class="keyword">as</span> img:</span><br><span class="line">            img.save(dst+PIC_NAME)</span><br><span class="line">    <span class="keyword">if</span> delete:</span><br><span class="line">        os.remove(PATH)</span><br><span class="line">    clear(tmp)</span><br><span class="line">    <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>
<p><code>category</code>表示证件类别，如果证件类别不存在，那么就默认识别整张图。因为身份证照片已经是规整的，因此<code>&quot;ratio&quot;</code>没有作用。经过实践，图像的预处理只需要进行转为灰度图并归一化即可。</p>
<p>转换为灰度图可以使用<code>PIL</code>中的<code>Image.convert('L')</code>。然后线性归一化就是将图片中每个像素放缩到<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn><mo>∼</mo><mn>255</mn></mrow><annotation encoding="application/x-tex">0 \sim 255</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∼</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord">5</span><span class="mord">5</span></span></span></span>范围:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># preprocess.py</span></span><br><span class="line"><span class="keyword">from</span> itertools <span class="keyword">import</span> permutations</span><br><span class="line"><span class="keyword">from</span> scipy <span class="keyword">import</span> ndimage</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="keyword">import</span> PIL.ImageOps</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">from</span> utils <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">normalized</span><span class="params">(img)</span>:</span></span><br><span class="line">    arr = np.array(img.copy().convert(<span class="string">'L'</span>))</span><br><span class="line">    arr_min = arr.min()</span><br><span class="line">    arr_max = arr.max()</span><br><span class="line">    arr = ((arr-arr_min)/(arr_max-arr_min)*<span class="number">255</span>).astype(np.uint8)</span><br><span class="line">    <span class="keyword">return</span> Image.fromarray(arr)</span><br></pre></td></tr></table></figure>
<p><img src="/img/2020-02-13-blog-01/id.png" alt="处理前后图片对比"></p>
<p>由于Tesseract的要求，图片的分辨率要足够高，不过似乎一般图片中不含dpi信息，因此手动设置dpi为<code>(300,300)</code>。</p>
<p>因为<code>subprocess</code>调用命令行可以形成新的进程，因此不需要每次调用Tesseract的时候等待其运行完，而可以先保存下来，等到真正需要读取数据时再等待，提高并行程度。</p>
<p>清理识别后数据，去除空格:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># utils.py</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">clean</span><span class="params">(s)</span>:</span></span><br><span class="line">    <span class="keyword">return</span>(s.replace(<span class="string">" "</span>,<span class="string">""</span>)</span><br><span class="line">            .replace(<span class="string">"\r"</span>,<span class="string">""</span>)</span><br><span class="line">            .replace(<span class="string">"\n"</span>,<span class="string">""</span>)</span><br><span class="line">            .replace(<span class="string">"\t"</span>,<span class="string">""</span>)</span><br><span class="line">            .replace(<span class="string">"\f"</span>,<span class="string">""</span>)</span><br><span class="line">            .replace(<span class="string">"\v"</span>,<span class="string">""</span>))</span><br></pre></td></tr></table></figure>
<p>这样就可以对身份证号和身份证地址进行基本的识别了。身份证号识别(测试了几张身份证以及不同角度)基本不会出错，而住址识别一般会出现<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn><mo>∼</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">0 \sim 2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∼</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span>个汉字的错误，关键信息基本不会出错。</p>
<p><strong>在保证光照均匀的情况下准确率都很高</strong>，有一些(我刻意测试)的光照情况下即使人看清上面某个特定位置的字也很困难，除此以外表现基本是可以接受的。</p>
<br>
<h3 id="了解身份证"><a class="markdownIt-Anchor" href="#了解身份证"></a> 了解身份证</h3>
<p>已经识别了身份证号和家庭地址，那么接下来就可以推广到识别整个身份证上的信息了。需要对所有信息分别找出其在身份证上的相对位置，写入配置文件中。实践证明，如果信息片<strong>面积过小，识别准确率会很低</strong>。性别、民族、出生年、出生月、出生日，识别框很小，只有一个汉字或几个数字，几乎很难识别正确。而姓名对于常见字识别准确率较高，相对不常见、复杂的字识别准确率则较低。<s>比如&quot;醉&quot;和&quot;醇&quot;有时傻傻分不清楚。</s></p>
<p>然而，身份证是非常特殊的。了解身份证可以对识别有帮助！这就需要了解身份证号的组成了: 二代居民身份证号码为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>18</mn></mrow><annotation encoding="application/x-tex">18</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">8</span></span></span></span>位，其中最后一位是校验码，可能出现<code>X</code>。计算方法为(来自百度百科):</p>
<ol>
<li>
<p>将前面的身份证号码17位数分别乘以不同的系数。从第一位到第十七位的系数分别为：7－9－10－5－8－4－2－1－6－3－7－9－10－5－8－4－2</p>
</li>
<li>
<p>将这17位数字和系数相乘的结果相加</p>
</li>
<li>
<p>用加出来和除以11，看余数是多少</p>
</li>
<li>
<p>余数只可能有0－1－2－3－4－5－6－7－8－9－10这11个数字。其分别对应的最后一位身份证的号码为1－0－X －9－8－7－6－5－4－3－2。(即余数0对应1，余数1对应0，余数2对应X…)</p>
</li>
</ol>
<p>因此我们可以按照上述过程实现对身份证号识别是否正确的<strong>校验</strong>(虽然一般都是正确的，不过还是有用的):</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># utils.py</span></span><br><span class="line">ID_verify = [<span class="number">7</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">5</span>,<span class="number">8</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">6</span>,<span class="number">3</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">5</span>,<span class="number">8</span>,<span class="number">4</span>,<span class="number">2</span>]</span><br><span class="line">ID_table  = <span class="string">"10X98765432"</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">check_ID_simple</span><span class="params">(s)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> ID_table[np.dot(ID_verify,[int(j) <span class="keyword">for</span> j <span class="keyword">in</span> s[:<span class="number">17</span>]])%<span class="number">11</span>]==s[<span class="number">17</span>] <span class="keyword">if</span> len(s)==<span class="number">18</span> <span class="keyword">and</span> s[:<span class="number">17</span>].isdigit() <span class="keyword">and</span> (s[<span class="number">17</span>] <span class="keyword">in</span> ID_table) <span class="keyword">else</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>
<p>当然真正合格的身份证号还需要更加严格检验: 比如出生日期是否是合法日期，身份证号前两位的出生地区码是否合法等。不过对于一个原本合格的身份证号，由于识别导致出现这些错误并且还能通过校验码验证的概率不大。</p>
<p>另外，针对身份证号可以在校验之前<strong>优化识别</strong>，去除识别过程中产生的杂乱符号而只保留数字以及最后一位的<code>X</code>:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># utils.py</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">clean_ID</span><span class="params">(s)</span>:</span></span><br><span class="line">    s = <span class="string">''</span>.join(list(filter(<span class="keyword">lambda</span> x: x <span class="keyword">in</span> ID_table,s)))</span><br><span class="line">    <span class="keyword">if</span> s==<span class="string">""</span>:</span><br><span class="line">        <span class="keyword">return</span> s</span><br><span class="line">    n = len(s)<span class="number">-1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">''</span>.join(list(filter(str.isdigit,s[:n])))+s[n]</span><br></pre></td></tr></table></figure>
<p>注意这里需要防止出现身份证号也没识别出来的情况。</p>
<p>类似地，对于数字以及信息的识别可以进行优化，分别去除非数字字符和标点符号:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># utils.py</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">clean_num</span><span class="params">(s)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">''</span>.join(list(filter(str.isdigit,s)))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">clean_info</span><span class="params">(s)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">''</span>.join(list(filter(<span class="keyword">lambda</span> x: x <span class="keyword">not</span> <span class="keyword">in</span> string.punctuation,s)))</span><br></pre></td></tr></table></figure>
<br>
<p>由于<strong>身份证内含出生年月日</strong>，因此不需要识别出生年月日，直接从身份证号中提取并合并为<code>&quot;{0}年{1}月{2}日&quot;.format(ID[6:10],ID[10:12],ID[12:14])</code>即可。</p>
<p>另外，对于身份证的第17位，满足<strong>男性为奇数，女性为偶数</strong>。因此，身份证信息不需要去识别性别，只需要把性别设置为<code>&quot;男&quot; if int(ID[16])%2 else &quot;女&quot;</code>即可。</p>
<p>对于照片的<code>&quot;M&quot;</code>类需要进行单独处理: 在发现<code>key</code>的第一位是<code>&quot;M&quot;</code>以后直接跳过识别和图像的灰度化和归一化。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># OCR.py</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">OCR</span><span class="params">(PIC_NAME,move=False,delete=False)</span>:</span></span><br><span class="line">    PATH = src+PIC_NAME</span><br><span class="line">    category = (deepcopy(config[PIC_NAME[:<span class="number">2</span>]]) <span class="keyword">if</span> PIC_NAME[:<span class="number">2</span>] <span class="keyword">in</span> config <span class="keyword">else</span> &#123;<span class="string">'info'</span>:&#123;<span class="string">'Z0'</span>:[<span class="number">0.</span>,<span class="number">0.</span>,<span class="number">1.</span>,<span class="number">1.</span>]&#125;&#125;)[<span class="string">'info'</span>]</span><br><span class="line">    result = &#123;&#125;</span><br><span class="line">    thread = &#123;&#125;</span><br><span class="line">    <span class="keyword">with</span> Image.open(PATH) <span class="keyword">as</span> img:</span><br><span class="line">        w,h = img.size</span><br><span class="line">        <span class="keyword">for</span> key,box <span class="keyword">in</span> category.items():</span><br><span class="line">            TEMP = tmp+key+<span class="string">"_"</span>+PIC_NAME</span><br><span class="line">            RESULT = tmp+key+<span class="string">"_"</span>+PIC_NAME.split(<span class="string">'.'</span>)[<span class="number">0</span>]</span><br><span class="line">            box[<span class="number">0</span>] *= w; box[<span class="number">1</span>] *= h; box[<span class="number">2</span>] *= w; box[<span class="number">3</span>] *= h</span><br><span class="line">            img_cr = img.crop([int(round(j)) <span class="keyword">for</span> j <span class="keyword">in</span> box])</span><br><span class="line">            <span class="comment"># img_cr.show()</span></span><br><span class="line">            <span class="keyword">if</span> key[<span class="number">0</span>]==<span class="string">'M'</span>:</span><br><span class="line">                img_cr.save(rst+key[<span class="number">1</span>:]+<span class="string">"_"</span>+PIC_NAME)</span><br><span class="line">                result[key] = key[<span class="number">1</span>:]+<span class="string">"_"</span>+PIC_NAME</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                img_cr = normalized(img_cr)</span><br><span class="line">                img_cr.save(TEMP,dpi=(<span class="number">300.0</span>,<span class="number">300.0</span>))</span><br><span class="line">                thread[key] = tesseract(TEMP,key[<span class="number">0</span>],RESULT)</span><br><span class="line">        <span class="keyword">for</span> key,box <span class="keyword">in</span> category.items():</span><br><span class="line">            <span class="keyword">if</span> key[<span class="number">0</span>]==<span class="string">'M'</span>:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            TEMP = tmp+key+<span class="string">"_"</span>+PIC_NAME</span><br><span class="line">            RESULT = tmp+key+<span class="string">"_"</span>+PIC_NAME.split(<span class="string">'.'</span>)[<span class="number">0</span>]+<span class="string">".txt"</span></span><br><span class="line">            thread[key].wait()</span><br><span class="line">            <span class="keyword">with</span> open(RESULT,<span class="string">"r"</span>,encoding=<span class="string">'UTF-8'</span>) <span class="keyword">as</span> f:</span><br><span class="line">                result[key] = clean(f.read())</span><br><span class="line">            <span class="keyword">if</span> key[<span class="number">0</span>]==<span class="string">'N'</span>:</span><br><span class="line">                result[key] = clean_num(result[key])</span><br><span class="line">    <span class="keyword">if</span> move:</span><br><span class="line">        <span class="keyword">with</span> Image.open(PATH) <span class="keyword">as</span> img:</span><br><span class="line">            img.save(dst+PIC_NAME)</span><br><span class="line">    <span class="keyword">if</span> delete:</span><br><span class="line">        os.remove(PATH)</span><br><span class="line">    clear(tmp)</span><br><span class="line">    <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>
<p>对于民族这一项，目前就没有什么好办法了…</p>
<br>
<h2 id="其他角度身份证照片ocr"><a class="markdownIt-Anchor" href="#其他角度身份证照片ocr"></a> 其他角度身份证照片OCR</h2>
<p>然而很难要求身份证总是拍的正正好好并且裁剪得完美。这样如果稍微有一点歪斜，原来手动标注的识别框就会完全失效。作为下一阶段的检测样例，刻意选取一个很过分的角度:</p>
<p><img src="/img/2020-02-13-blog-01/sf2.png" alt="手动标注一时爽，换个角度火葬场"></p>
<p>即使是角度不对，也不能太过分。为了简单起见，对图片进行下列假定:</p>
<ol>
<li>
<p>整个身份证都出现在图片内</p>
</li>
<li>
<p>图片光照均匀，无强光，无严重阴影</p>
</li>
<li>
<p>背景最好为均匀纯色，减少线条和明显差异</p>
</li>
<li>
<p>身份证倾角不会过大，最好在45以内</p>
</li>
</ol>
<p>虽然由于桌子的木纹和边缘，上述照片其实不满足条件<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>3</mn></mrow><annotation encoding="application/x-tex">3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">3</span></span></span></span>。不过最后效果还是不错的。</p>
<p>主要思路是，在背景均匀、身份证完全位于图片内的条件下，利用身份证的边缘作为从图像中识别出身份证位置的依据。<strong>核心问题就是寻找身份证的四个角点，只要找到四个角点，进行一次仿射变换即可提取出规整的身份证照片</strong>。</p>
<br>
<h3 id="进一步预处理"><a class="markdownIt-Anchor" href="#进一步预处理"></a> 进一步预处理</h3>
<p>首先就要让身份证的轮廓更加明显。因此采用常用的图像预处理方式: 灰度化-归一化-去噪声-二值化-腐蚀和膨胀/闭运算和开运算。灰度化和归一化前面已经进行过了。</p>
<p>代码方面，OpenCV的<code>cv2</code>和<code>PIL</code>的<code>Image</code>是两个完全不同的系统，需要注意区分。代码中用<code>img</code>表示<code>PIL.Image</code>变量，用<code>arr</code>表示OpenCV的图像即<code>numpy.ndarray</code>变量。</p>
<p><img src="/img/2020-02-13-blog-01/normalized.png" alt="灰度化和归一化的图像"></p>
<p>高斯模糊对图像做平滑处理，可以去噪。其中<code>(9,9)</code>为高斯卷积核大小(必须为奇数或<code>0</code>表示自动)，<code>0</code>为X方向标准差(Y方向标准差自动等于X方向):</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">blurred = cv2.GaussianBlur(arr,(<span class="number">9</span>,<span class="number">9</span>),<span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<p><img src="/img/2020-02-13-blog-01/blurred.png" alt="高斯模糊的图像"></p>
<br>
<p>二值化，将图像变为黑白两色。其中阈值<code>THRESH</code>处填入一个自己设置的<s>玄学的</s>常数:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_,binary = cv2.threshold(blurred,THRESH,<span class="number">255</span>,cv2.THRESH_BINARY)</span><br></pre></td></tr></table></figure>
<p><img src="/img/2020-02-13-blog-01/binary.png" alt="二值化图像"></p>
<br>
<p>对图像先后进行闭运算和开运算(似乎没有看出图片有很大区别，可以观察文字，图像的零散部分被一定程度上抹平)。<code>kernel</code>为卷积核，其类型为矩形(<code>cv2.MORPH_RECT</code>)，大小为<code>(5,5)</code>。腐蚀就是图像每个点求局部最小值(因为黑色灰度为<code>0</code>，这使图像变黑)，膨胀就是对图像每个点求局部最大值(因为白色灰度为<code>255</code>，这使图像变白)；闭运算就是先膨胀再腐蚀，开运算就是先腐蚀再膨胀:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">kernel = cv2.getStructuringElement(cv2.MORPH_RECT,(<span class="number">5</span>,<span class="number">5</span>))</span><br><span class="line">closed = cv2.morphologyEx(binary,cv2.MORPH_CLOSE,kernel)</span><br><span class="line">result = cv2.morphologyEx(closed,cv2.MORPH_OPEN,kernel)</span><br></pre></td></tr></table></figure>
<p><img src="/img/2020-02-13-blog-01/closed.png" alt="闭运算后图像"></p>
<p><img src="/img/2020-02-13-blog-01/opened.png" alt="开运算后图像"></p>
<br>
<p>~~实践表明，一般情况下身份证颜色相对环境都很浅，~~将图像反色一下效果更好:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">result = <span class="number">255</span>-result</span><br></pre></td></tr></table></figure>
<p><img src="/img/2020-02-13-blog-01/inverted.png" alt="反色图像"></p>
<br>
<p>完整的图像处理函数(不包括之前已经做了的灰度化和二值化):</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># preprocess.py</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">opened</span><span class="params">(arr,invert=True)</span>:</span></span><br><span class="line">    blurred = cv2.GaussianBlur(arr,(<span class="number">9</span>,<span class="number">9</span>),<span class="number">0</span>)</span><br><span class="line">    _,binary = cv2.threshold(blurred,THRESH,<span class="number">255</span>,cv2.THRESH_BINARY)</span><br><span class="line">    kernel = cv2.getStructuringElement(cv2.MORPH_RECT,(<span class="number">5</span>,<span class="number">5</span>))</span><br><span class="line">    closed = cv2.morphologyEx(binary,cv2.MORPH_CLOSE,kernel)</span><br><span class="line">    result = cv2.morphologyEx(closed,cv2.MORPH_OPEN,kernel)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">255</span>-result <span class="keyword">if</span> invert <span class="keyword">else</span> result</span><br></pre></td></tr></table></figure>
<br>
<h3 id="边缘检测"><a class="markdownIt-Anchor" href="#边缘检测"></a> 边缘检测</h3>
<p>尝试利用边缘检测来寻找身份证的四个角点。</p>
<p>使用OpenCV提供的<code>cv2.Canny</code>方法先对已经二值化过的图像进行边缘检测。其中<code>CANNY_LOW</code>和<code>CANNY_HIGH</code>处也要填入两个<s>玄学的</s>常数，高于第二个阈值的像素会被直接保留，低于第一个阈值的像素会被直接抛弃，在两个阈值之间的像素会被进行进一步的检测(比较周围像素)。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">opened_arr = opened(arr)</span><br><span class="line">edges = cv2.Canny(opened_arr,CANNY_LOW,CANNY_HIGH,apertureSize=<span class="number">3</span>)</span><br></pre></td></tr></table></figure>
<p><img src="/img/2020-02-13-blog-01/edges.png" alt="Canny边缘检测结果，你看马赛克都不用打了(雾)"></p>
<br>
<p>接下来从这些边缘中提取线段，使用OpenCV提供的霍夫变换。使用<code>cv2.HoughLines</code>会得到<strong>直线</strong>到原点距离线段的<strong>极坐标</strong>表示，使用<code>cv2.HoughLinesP</code>会得到<strong>线段</strong>的<strong>直角坐标</strong>表示。<code>rho</code>和<code>theta</code>顾名思义分别规定了距离和角度的精度要求，这两项一般不动。接下来又是<s>喜闻乐见的</s>常数环节，<code>HOUGH_THRESH</code>是阈值，只保留大于阈值的线段；<code>HOUGH_MIN_LEN</code>为线段长度，只保留大于该长度的线段；<code>HOUGH_MAX_GAP</code>表示最大间隔，如果两个平行共线的线段之间距离不超过<code>HOUGH_MAX_GAP</code>就会被连接起来被认为是一条线段。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lines = cv2.HoughLinesP(edges, rho=<span class="number">1</span>, theta=np.pi/<span class="number">180</span>, threshold=HOUGH_THRESH, minLineLength=HOUGH_MIN_LEN, maxLineGap=HOUGH_MAX_GAP)</span><br></pre></td></tr></table></figure>
<p>这一过程可能会找出成千上万条线段来，返回的<code>list</code>基本会按照可信度排序。因此将前<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>20</mn></mrow><annotation encoding="application/x-tex">20</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord">0</span></span></span></span>条线段在图上做出来观察一下识别效果。到Canny边缘检测以后，图像基本不再进行处理和修改了，从此以后使用原来的灰度化归一化图像作为基底做图方便观察。使用下述代码进行可视化: 不知道为什么<code>cv2.HoughLinesP</code>返回值要包装成两层列表，因此会比较别扭；用<code>cv2.line</code>在图像上绘制线条，首先输入图像，再输入两个点坐标，<code>0</code>表示颜色为黑色，<code>10</code>表示线条粗细。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">blank = arr</span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> lines[:<span class="number">20</span>]:</span><br><span class="line">    <span class="keyword">for</span> x1,y1,x2,y2 <span class="keyword">in</span> j:</span><br><span class="line">        cv2.line(blank,(x1,y1),(x2,y2),<span class="number">0</span>,<span class="number">10</span>)</span><br><span class="line">cv2.imshow(<span class="string">"lines"</span>,blank)</span><br><span class="line">cv2.waitKey(<span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<p><img src="/img/2020-02-13-blog-01/lines.png" alt="边缘线条"></p>
<p>虽然看起来没有<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>20</mn></mrow><annotation encoding="application/x-tex">20</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord">0</span></span></span></span>条线，但是霍夫变换返回的有很多线条可能是接近重合的。同样，它们的顺序也不清楚。<strong>边缘检测在这张图片中效果不错，但在其他图片中效果并没有这么好。<strong>在一些其他图片中，由于不能保证背景均匀和光照均匀，可能会出现不想要的线条。因此直接用这些线条来计算身份证的四个角是不太好的。而且由于视角的变化，这些线段甚至不一定成<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>90</mn></mrow><annotation encoding="application/x-tex">90</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">9</span><span class="mord">0</span></span></span></span>度，因此一个很大的难点就是</strong>如何保证找到的线段一定是身份证的边界而不是背景中的线条呢？</strong></p>
<p>需要思考进一步优化识别、区分线段的方法。</p>
<br>
<h3 id="矩形包围盒"><a class="markdownIt-Anchor" href="#矩形包围盒"></a> 矩形包围盒</h3>
<p>除了边缘检测，另一个思路是寻找身份证的矩形包围盒。</p>
<p>身份证的性状是一个规则的四边形，可以考虑通过寻找包围盒来获得身份证的位置。使用<code>cv2.findContours</code>首先将图像的轮廓描出来，然后利用轮廓计算包围盒<code>cv2.minAreaRect</code>。注意到<code>cv2.findContours</code>也会找出很多个轮廓。因此<strong>假定身份证图片是图片中最大的轮廓</strong>，这个假设在背景均匀时一般比较合理。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># preprocess.py</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bounding_box</span><span class="params">(opened_arr)</span>:</span></span><br><span class="line">    contours,_ = cv2.findContours(opened_arr,cv2.RETR_LIST,cv2.CHAIN_APPROX_SIMPLE)</span><br><span class="line">    bounding_rect = cv2.minAreaRect(sorted(contours,key=cv2.contourArea,reverse=<span class="literal">True</span>)[<span class="number">1</span>])</span><br><span class="line">    <span class="keyword">return</span> np.int0(cv2.boxPoints(bounding_rect))</span><br></pre></td></tr></table></figure>
<p>分别可视化绘制一下轮廓和包围盒。使用<code>cv2.drawContours</code>，<code>-1</code>表示绘制所有轮廓；<code>0</code>表示颜色为黑色；<code>10</code>为线条粗细:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">blank = cv2.drawContours(arr,contours,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">10</span>)</span><br><span class="line">cv2.imshow(<span class="string">"contour"</span>,blank)</span><br><span class="line">cv2.waitKey(<span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<p><img src="/img/2020-02-13-blog-01/contour.png" alt="所有轮廓"></p>
<br>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">box = bounding_box(opened_arr)</span><br><span class="line">blank = cv2.drawContours(arr,[box],<span class="number">-1</span>,<span class="number">0</span>,<span class="number">10</span>)</span><br><span class="line">cv2.imshow(<span class="string">"bounding_box"</span>,blank)</span><br><span class="line">cv2.waitKey(<span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<p><img src="/img/2020-02-13-blog-01/bounding_box.png" alt="矩形包围盒"></p>
<br>
<p>由于视角的变换，原本的身份证并不是矩形了，因此这样一个矩形包围盒可以作为一个<strong>良好的近似</strong>，但并不可能直接使用。</p>
<br>
<h3 id="mix"><a class="markdownIt-Anchor" href="#mix"></a> Mix!</h3>
<p>边缘检测的方法也行不通，矩形包围盒的方法也行不通，那… Why not try BOTH?</p>
<p>既然矩形包围盒已经是身份证一个良好的近似了，那么可以利用这个近似的包围盒来筛选线段！只保留和矩形包围盒边界比较近似的线段就可以获得只属于身份证的线段了！</p>
<p>这里要先做好一些图形计算的辅助函数来<s>展示OI选手计算几何的基本功底</s>方便以后的操作，主要包括求距离、叉积、角度、判平行、求交(常数<code>DIFF_ANGLE</code>可视情况自己取):</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># utils.py</span></span><br><span class="line"></span><br><span class="line">DIFF_ANGLE = <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sqrdis</span><span class="params">(a,b)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> (a[<span class="number">0</span>]-b[<span class="number">0</span>])**<span class="number">2</span>+(a[<span class="number">1</span>]-b[<span class="number">1</span>])**<span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">product</span><span class="params">(a,b)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> a[<span class="number">0</span>]*b[<span class="number">1</span>]-a[<span class="number">1</span>]*b[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">angle</span><span class="params">(a)</span>:</span></span><br><span class="line">    r = math.degrees(math.atan2(a[<span class="number">1</span>],a[<span class="number">0</span>]))</span><br><span class="line">    <span class="keyword">if</span> r &gt; <span class="number">180</span>:</span><br><span class="line">        r -= <span class="number">180</span></span><br><span class="line">    <span class="keyword">if</span> r &lt; <span class="number">0</span>:</span><br><span class="line">        r += <span class="number">180</span></span><br><span class="line">    <span class="keyword">return</span> r</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">parallel</span><span class="params">(line1,line2)</span>:</span></span><br><span class="line">    a = np.array(line1[:<span class="number">2</span>],dtype=np.float32) - np.array(line1[<span class="number">2</span>:],dtype=np.float32)</span><br><span class="line">    b = np.array(line2[:<span class="number">2</span>],dtype=np.float32) - np.array(line2[<span class="number">2</span>:],dtype=np.float32)</span><br><span class="line">    diff = math.fabs(angle(a) - angle(b))</span><br><span class="line">    <span class="keyword">return</span> diff &lt;= DIFF_ANGLE <span class="keyword">or</span> diff &gt;= <span class="number">180</span>-DIFF_ANGLE</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cross</span><span class="params">(line1,line2)</span>:</span></span><br><span class="line">    a = np.array(line1[:<span class="number">2</span>],dtype=np.float32); b = np.array(line1[<span class="number">2</span>:],dtype=np.float32);</span><br><span class="line">    c = np.array(line2[:<span class="number">2</span>],dtype=np.float32); d = np.array(line2[<span class="number">2</span>:],dtype=np.float32)</span><br><span class="line">    <span class="keyword">return</span> a+(product(d-c,a-c)/product(b-a,d-c))*(b-a)</span><br></pre></td></tr></table></figure>
<p>接下来用每个线段去匹配包围盒的每条边，枚举哪两对点匹配，以两对点的距离平方和作为排序依据，取误差最小的前<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>20</mn></mrow><annotation encoding="application/x-tex">20</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord">0</span></span></span></span>条线段。<s>顺手把线段的二层列表去掉一层。</s></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">opened_arr = opened(arr)</span><br><span class="line">box = bounding_box(opened_arr)</span><br><span class="line">edges = cv2.Canny(opened_arr,CANNY_LOW,CANNY_HIGH,apertureSize=<span class="number">3</span>)</span><br><span class="line">lines = cv2.HoughLinesP(edges, rho=<span class="number">1</span>, theta=np.pi/<span class="number">180</span>, threshold=HOUGH_THRESH, minLineLength=HOUGH_MIN_LEN, maxLineGap=HOUGH_MAX_GAP)</span><br><span class="line">lines = sorted(lines,</span><br><span class="line">               key=<span class="keyword">lambda</span> x:min([sqrdis(x[<span class="number">0</span>][:<span class="number">2</span>],box[<span class="number">0</span>])+sqrdis(x[<span class="number">0</span>][<span class="number">2</span>:],box[<span class="number">1</span>]),</span><br><span class="line">                                 sqrdis(x[<span class="number">0</span>][<span class="number">2</span>:],box[<span class="number">0</span>])+sqrdis(x[<span class="number">0</span>][:<span class="number">2</span>],box[<span class="number">1</span>]),</span><br><span class="line">                                 sqrdis(x[<span class="number">0</span>][:<span class="number">2</span>],box[<span class="number">1</span>])+sqrdis(x[<span class="number">0</span>][<span class="number">2</span>:],box[<span class="number">2</span>]),</span><br><span class="line">                                 sqrdis(x[<span class="number">0</span>][<span class="number">2</span>:],box[<span class="number">1</span>])+sqrdis(x[<span class="number">0</span>][:<span class="number">2</span>],box[<span class="number">2</span>]),</span><br><span class="line">                                 sqrdis(x[<span class="number">0</span>][:<span class="number">2</span>],box[<span class="number">2</span>])+sqrdis(x[<span class="number">0</span>][<span class="number">2</span>:],box[<span class="number">3</span>]),</span><br><span class="line">                                 sqrdis(x[<span class="number">0</span>][<span class="number">2</span>:],box[<span class="number">2</span>])+sqrdis(x[<span class="number">0</span>][:<span class="number">2</span>],box[<span class="number">3</span>]),</span><br><span class="line">                                 sqrdis(x[<span class="number">0</span>][:<span class="number">2</span>],box[<span class="number">3</span>])+sqrdis(x[<span class="number">0</span>][<span class="number">2</span>:],box[<span class="number">0</span>]),</span><br><span class="line">                                 sqrdis(x[<span class="number">0</span>][<span class="number">2</span>:],box[<span class="number">3</span>])+sqrdis(x[<span class="number">0</span>][:<span class="number">2</span>],box[<span class="number">0</span>])</span><br><span class="line">                               ]),</span><br><span class="line">               reverse=<span class="literal">False</span>)</span><br><span class="line">lines = [np.array(x[<span class="number">0</span>],dtype=np.float32) <span class="keyword">for</span> x <span class="keyword">in</span> lines[:LINES]]</span><br></pre></td></tr></table></figure>
<p><img src="/img/2020-02-13-blog-01/lines_sorted.png" alt="重新排序的前20线段，这张图恰巧没什么区别...其他一些照片还是有区别的"></p>
<br>
<p>然后对线段求交，正如上文所说，霍夫变换会得到很多重复的线段，因此求交点之前需要判断平行，求出交点后需要去重(常数<code>DIFF_SQRDIS</code>自己取，注意是平方距离所以这个值要比较大)。另外，要将一些落在图像外的明显是噪音的点去掉，对于恰好落在图像边缘附近的点宽容一些空间(常数<code>EDGE</code>自己取)。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># preprocess.py</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">crosses</span><span class="params">(lines,w,h)</span>:</span></span><br><span class="line">    points = []</span><br><span class="line">    unique_points = []</span><br><span class="line">    <span class="keyword">for</span> a <span class="keyword">in</span> lines:</span><br><span class="line">        <span class="keyword">for</span> b <span class="keyword">in</span> lines:</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> parallel(a,b):</span><br><span class="line">                p = cross(a,b)</span><br><span class="line">                <span class="keyword">if</span> -EDGE &lt;= p[<span class="number">0</span>] &lt;= w+EDGE <span class="keyword">and</span> -EDGE &lt;= p[<span class="number">1</span>] &lt;= h+EDGE:</span><br><span class="line">                    points.append(p)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(points)):</span><br><span class="line">        flag = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(i):</span><br><span class="line">            <span class="keyword">if</span> sqrdis(points[i],points[j]) &lt; DIFF_SQRDIS:</span><br><span class="line">                flag = <span class="literal">False</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">if</span> flag:</span><br><span class="line">            unique_points.append(points[i])</span><br><span class="line">    <span class="keyword">return</span> unique_points</span><br></pre></td></tr></table></figure>
<p>求出的线段交点不出意外的话应该是四个。可视化一下，在图像上画点显然是没啥效果的，用画圆的方式来可视化。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">blank = arr</span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> lines:</span><br><span class="line">    cv2.line(blank,(j[<span class="number">0</span>],j[<span class="number">1</span>]),(j[<span class="number">2</span>],j[<span class="number">3</span>]),<span class="number">0</span>,<span class="number">10</span>)</span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> points:</span><br><span class="line">    cv2.circle(blank,(j[<span class="number">0</span>],j[<span class="number">1</span>]),<span class="number">10</span>,<span class="number">0</span>,<span class="number">-1</span>)</span><br><span class="line">cv2.imshow(<span class="string">"img"</span>,blank)</span><br><span class="line">cv2.waitKey(<span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<p><img src="/img/2020-02-13-blog-01/points.png" alt="线段和线段交点"></p>
<br>
<p>很棒！终于找到了<strong>身份证的四个角点</strong>。</p>
<br>
<h3 id="仿射变换和透视变换"><a class="markdownIt-Anchor" href="#仿射变换和透视变换"></a> 仿射变换和透视变换</h3>
<p>现在已经知道身份证的四个角点了，要得到一个正规的身份证照片，需要将四个角点通过视角的变换运算到<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><mn>0</mn><mo separator="true">,</mo><mn>0</mn><mo stretchy="false">)</mo><mo separator="true">,</mo><mo stretchy="false">(</mo><mn>0</mn><mo separator="true">,</mo><mi>h</mi><mo stretchy="false">)</mo><mo separator="true">,</mo><mo stretchy="false">(</mo><mi>w</mi><mo separator="true">,</mo><mi>h</mi><mo stretchy="false">)</mo><mo separator="true">,</mo><mo stretchy="false">(</mo><mi>w</mi><mo separator="true">,</mo><mn>0</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(0,0),(0,h),(w,h),(w,0)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">0</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mopen">(</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">h</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">h</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">0</span><span class="mclose">)</span></span></span></span>。</p>
<p>首先注意到这四个点是乱序的，按逆时针顺序匹配一下。<strong>假设存在一条竖直中线可以将身份证分为左右两部分</strong>，这个假设也是合理的，否则根据身份证的长宽比<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1.5</mn><mover accent="true"><mn>8</mn><mo>˙</mo></mover><mn>5</mn><mover accent="true"><mn>1</mn><mo>˙</mo></mover></mrow><annotation encoding="application/x-tex">1.5\dot 85 \dot 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8813em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">.</span><span class="mord">5</span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8813em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord">8</span></span><span style="top:-3.21344em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.13889em;">˙</span></span></span></span></span></span><span class="mord">5</span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8813em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord">1</span></span><span style="top:-3.21344em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.13889em;">˙</span></span></span></span></span></span></span></span></span>，身份证倾角会达到<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>57</mn><mi mathvariant="normal">°</mi></mrow><annotation encoding="application/x-tex">57°</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord">5</span><span class="mord">7</span><span class="mord">°</span></span></span></span>。那么就认为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>号点是左侧高度较高的点，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>号点是左侧高度较低的点，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn></mrow><annotation encoding="application/x-tex">2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span>号点是右侧高度较低的点，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>3</mn></mrow><annotation encoding="application/x-tex">3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">3</span></span></span></span>号点是右侧高度较高的点。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># preprocess.py</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">matched</span><span class="params">(points)</span>:</span></span><br><span class="line">    <span class="keyword">assert</span>(len(points)==<span class="number">4</span>)</span><br><span class="line">    points = sorted(points,key=<span class="keyword">lambda</span> x:x[<span class="number">0</span>])</span><br><span class="line">    <span class="keyword">if</span> points[<span class="number">0</span>][<span class="number">1</span>] &gt; points[<span class="number">1</span>][<span class="number">1</span>]:</span><br><span class="line">        points[<span class="number">0</span>],points[<span class="number">1</span>] = points[<span class="number">1</span>],points[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">if</span> points[<span class="number">3</span>][<span class="number">1</span>] &gt; points[<span class="number">2</span>][<span class="number">1</span>]:</span><br><span class="line">        points[<span class="number">2</span>],points[<span class="number">3</span>] = points[<span class="number">3</span>],points[<span class="number">2</span>]</span><br><span class="line">    <span class="keyword">return</span> np.array(points,dtype=np.float32)</span><br></pre></td></tr></table></figure>
<p>~~众所周知，~~一个空间中的变换可以用一个<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>3</mn><mo>×</mo><mn>3</mn></mrow><annotation encoding="application/x-tex">3 \times 3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">3</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">3</span></span></span></span>矩阵来表示，三个点就可以确定一个变换。因此只需要使用身份证四个角点中的三个，利用<code>cv2.getAffineTransform</code>来寻找<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn><mo separator="true">,</mo><mn>1</mn><mo separator="true">,</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">0,1,2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8388800000000001em;vertical-align:-0.19444em;"></span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">2</span></span></span></span>号点变为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><mn>0</mn><mo separator="true">,</mo><mn>0</mn><mo stretchy="false">)</mo><mo separator="true">,</mo><mo stretchy="false">(</mo><mn>0</mn><mo separator="true">,</mo><mi>h</mi><mo stretchy="false">)</mo><mo separator="true">,</mo><mo stretchy="false">(</mo><mi>w</mi><mo separator="true">,</mo><mi>h</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(0,0),(0,h),(w,h)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">0</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mopen">(</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">h</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">h</span><span class="mclose">)</span></span></span></span>的变换矩阵即可。不过，OpenCV还恰好提供了一个利用四个点来寻找变换的<code>cv2.getPerspectiveTransform</code>，那为什么不用呢？于是就可以完整实现下面的函数来求出变换矩阵:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># preprocess.py</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">affine</span><span class="params">(arr)</span>:</span></span><br><span class="line">    h,w = arr.shape</span><br><span class="line">    opened_arr = opened(arr)</span><br><span class="line">    box = bounding_box(opened_arr)</span><br><span class="line">    edges = cv2.Canny(opened_arr,CANNY_LOW,CANNY_HIGH,apertureSize=<span class="number">3</span>)</span><br><span class="line">    lines = cv2.HoughLinesP(edges, rho=<span class="number">1</span>, theta=np.pi/<span class="number">180</span>, threshold=HOUGH_THRESH, minLineLength=HOUGH_MIN_LEN, maxLineGap=HOUGH_MAX_GAP)</span><br><span class="line">    lines = sorted(lines,</span><br><span class="line">                   key=<span class="keyword">lambda</span> x:min([sqrdis(x[<span class="number">0</span>][:<span class="number">2</span>],box[<span class="number">0</span>])+sqrdis(x[<span class="number">0</span>][<span class="number">2</span>:],box[<span class="number">1</span>]),</span><br><span class="line">                                     sqrdis(x[<span class="number">0</span>][<span class="number">2</span>:],box[<span class="number">0</span>])+sqrdis(x[<span class="number">0</span>][:<span class="number">2</span>],box[<span class="number">1</span>]),</span><br><span class="line">                                     sqrdis(x[<span class="number">0</span>][:<span class="number">2</span>],box[<span class="number">1</span>])+sqrdis(x[<span class="number">0</span>][<span class="number">2</span>:],box[<span class="number">2</span>]),</span><br><span class="line">                                     sqrdis(x[<span class="number">0</span>][<span class="number">2</span>:],box[<span class="number">1</span>])+sqrdis(x[<span class="number">0</span>][:<span class="number">2</span>],box[<span class="number">2</span>]),</span><br><span class="line">                                     sqrdis(x[<span class="number">0</span>][:<span class="number">2</span>],box[<span class="number">2</span>])+sqrdis(x[<span class="number">0</span>][<span class="number">2</span>:],box[<span class="number">3</span>]),</span><br><span class="line">                                     sqrdis(x[<span class="number">0</span>][<span class="number">2</span>:],box[<span class="number">2</span>])+sqrdis(x[<span class="number">0</span>][:<span class="number">2</span>],box[<span class="number">3</span>]),</span><br><span class="line">                                     sqrdis(x[<span class="number">0</span>][:<span class="number">2</span>],box[<span class="number">3</span>])+sqrdis(x[<span class="number">0</span>][<span class="number">2</span>:],box[<span class="number">0</span>]),</span><br><span class="line">                                     sqrdis(x[<span class="number">0</span>][<span class="number">2</span>:],box[<span class="number">3</span>])+sqrdis(x[<span class="number">0</span>][:<span class="number">2</span>],box[<span class="number">0</span>])</span><br><span class="line">                                   ]),</span><br><span class="line">                   reverse=<span class="literal">False</span>)</span><br><span class="line">    lines = [np.array(x[<span class="number">0</span>],dtype=np.float32) <span class="keyword">for</span> x <span class="keyword">in</span> lines[:LINES]]</span><br><span class="line">    points = crosses(lines,w,h)</span><br><span class="line">    <span class="comment"># blank = arr</span></span><br><span class="line">    <span class="comment"># for j in lines:</span></span><br><span class="line">    <span class="comment">#     cv2.line(blank,(j[0],j[1]),(j[2],j[3]),0,10)</span></span><br><span class="line">    <span class="comment"># for j in points:</span></span><br><span class="line">    <span class="comment">#     cv2.circle(blank,(j[0],j[1]),10,0,-1)</span></span><br><span class="line">    <span class="comment"># cv2.imshow("img",blank)</span></span><br><span class="line">    <span class="comment"># cv2.waitKey(0)</span></span><br><span class="line">    <span class="keyword">return</span> cv2.getPerspectiveTransform(matched(points),np.array([[<span class="number">0</span>,<span class="number">0</span>],[<span class="number">0</span>,h],[w,h],[w,<span class="number">0</span>]],dtype=np.float32))</span><br></pre></td></tr></table></figure>
<p>注意一下OpenCV格式(<code>numpy.ndarray</code>)存储的图片的性状是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>h</mi><mo>×</mo><mi>w</mi></mrow><annotation encoding="application/x-tex">h \times w</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">h</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span></span></span></span>，与<code>PIL.Image.size</code>的<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>w</mi><mo>×</mo><mi>h</mi></mrow><annotation encoding="application/x-tex">w \times h</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">h</span></span></span></span>不同。</p>
<br>
<p>接下来在没有处理过的原图上进行仿射变换就可以得到正规的身份证照片了。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># preprocess.py</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">align</span><span class="params">(img)</span>:</span></span><br><span class="line">    arr = np.array(img.copy().convert(<span class="string">'L'</span>))</span><br><span class="line">    h,w = arr.shape</span><br><span class="line">    transform = affine(arr)</span><br><span class="line">    arr = cv2.warpPerspective(np.array(img),transform,(w,h))</span><br><span class="line">    <span class="keyword">return</span> Image.fromarray(arr)</span><br></pre></td></tr></table></figure>
<p>注意正规化以后的身份证长宽比<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>w</mi><mo>:</mo><mi>h</mi></mrow><annotation encoding="application/x-tex">w:h</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">h</span></span></span></span>是图像的长宽比。因此利用<code>&quot;ratio&quot;</code>对图片resize一下:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">img = img.resize((w,h),Image.ANTIALIAS)</span><br></pre></td></tr></table></figure>
<p>看一看正规化后、比例正确的照片(代码中直接用正规化后的照片替换了原照片):</p>
<p><img src="/img/2020-02-13-blog-01/sf3.png" alt="OHHHHHHHHHHHHHHHHHHHHHHHHH!"></p>
<p>真的是从之前那张照片变换回来的！！！</p>
<br>
<h3 id="了解身份证-2"><a class="markdownIt-Anchor" href="#了解身份证-2"></a> 了解身份证 · 2</h3>
<p>然而怎么判断身份证需不需要变换呢，如果本来就是一张正规的身份证照片怎么办？</p>
<p>这里用了一个取巧的办法，牺牲一点性能: 定义一个<code>&quot;id&quot;</code>类只识别身份证号。</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"sf"</span>:</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">"ratio"</span>: <span class="number">1.5851851851851851851851851851852</span>,</span><br><span class="line">        <span class="attr">"info"</span>:</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">"Eid"</span>: [<span class="number">0.3253</span>,<span class="number">0.8185</span>,<span class="number">0.8842</span>,<span class="number">0.9185</span>],</span><br><span class="line">            <span class="attr">"Zname"</span>: [<span class="number">0.1700</span>,<span class="number">0.1200</span>,<span class="number">0.3276</span>,<span class="number">0.2241</span>],</span><br><span class="line">            <span class="attr">"Zaddress"</span>: [<span class="number">0.1723</span>,<span class="number">0.5148</span>,<span class="number">0.6065</span>,<span class="number">0.7583</span>],</span><br><span class="line">            <span class="attr">"Mpicture"</span>: [<span class="number">0.5982</span>,<span class="number">0.1481</span>,<span class="number">0.9400</span>,<span class="number">0.7593</span>]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"id"</span>:</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">"ratio"</span>: <span class="number">1.5851851851851851851851851851852</span>,</span><br><span class="line">        <span class="attr">"info"</span>:</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">"Eid"</span>: [<span class="number">0.3253</span>,<span class="number">0.8185</span>,<span class="number">0.8842</span>,<span class="number">0.9185</span>]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为身份证号的识别成功率是很高的，因此只要正规的身份证切的位置对，可以先识别一下身份证号，用之前的<code>check_ID_simple</code>函数检验是否正确！如果正确说明本来就正规了，直接识别即可，否则需要进行变换。</p>
<p>可以再添加一些针对身份证识别的优化(例如如果用手机照，可能身份证会竖过来，根据长宽旋转下)，写成一个单独的身份证识别函数:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># OCR.py</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">ID_Card_OCR</span><span class="params">(PIC_NAME)</span>:</span></span><br><span class="line">    <span class="keyword">assert</span>(PIC_NAME[:<span class="number">2</span>]==<span class="string">"sf"</span> <span class="keyword">and</span> <span class="string">"sf"</span> <span class="keyword">in</span> config)</span><br><span class="line">    PATH = src+PIC_NAME</span><br><span class="line">    ID_PIC = <span class="string">"id"</span>+PIC_NAME[<span class="number">2</span>:]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">with</span> Image.open(PATH) <span class="keyword">as</span> img:</span><br><span class="line">        w,h = img.size</span><br><span class="line">        <span class="keyword">if</span> w &lt; h:</span><br><span class="line">            img = img.transpose(Image.ROTATE_90); w,h = h,w</span><br><span class="line">        img.save(PATH,dpi=(<span class="number">300.0</span>,<span class="number">300.0</span>))</span><br><span class="line">        img.save(src+ID_PIC,dpi=(<span class="number">300.0</span>,<span class="number">300.0</span>))</span><br><span class="line">    </span><br><span class="line">    ID = clean_ID(OCR(ID_PIC,delete=<span class="literal">True</span>)[<span class="string">'Eid'</span>])</span><br><span class="line">    <span class="keyword">if</span> check_ID_simple(ID):</span><br><span class="line">        result = OCR(PIC_NAME)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">with</span> Image.open(PATH) <span class="keyword">as</span> img:</span><br><span class="line">            img = align(img)</span><br><span class="line">            w,h = img.size</span><br><span class="line">            w = int(h * config[PIC_NAME[:<span class="number">2</span>]][<span class="string">'ratio'</span>])</span><br><span class="line">            img = img.resize((w,h),Image.ANTIALIAS)</span><br><span class="line">            <span class="comment"># img.show()</span></span><br><span class="line">            <span class="comment"># exit(0)</span></span><br><span class="line">            img.save(PATH,dpi=(<span class="number">300.0</span>,<span class="number">300.0</span>))</span><br><span class="line">        result = OCR(PIC_NAME)</span><br><span class="line">        ID = clean_ID(result[<span class="string">'Eid'</span>])</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> check_ID_simple(ID):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">    result[<span class="string">'id'</span>] = ID</span><br><span class="line">    result[<span class="string">'picture'</span>] = result[<span class="string">'Mpicture'</span>]</span><br><span class="line">    result[<span class="string">'name'</span>] = clean_info(result[<span class="string">'Zname'</span>])</span><br><span class="line">    result[<span class="string">'address'</span>] = clean_info(result[<span class="string">'Zaddress'</span>])</span><br><span class="line">    <span class="keyword">del</span> result[<span class="string">'Eid'</span>],result[<span class="string">'Mpicture'</span>],result[<span class="string">'Zname'</span>],result[<span class="string">'Zaddress'</span>]</span><br><span class="line">    result[<span class="string">'sex'</span>] = <span class="string">"男"</span> <span class="keyword">if</span> int(ID[<span class="number">16</span>])%<span class="number">2</span> <span class="keyword">else</span> <span class="string">"女"</span></span><br><span class="line">    result[<span class="string">'birthdate'</span>] = <span class="string">"&#123;0&#125;年&#123;1&#125;月&#123;2&#125;日"</span>.format(ID[<span class="number">6</span>:<span class="number">10</span>],ID[<span class="number">10</span>:<span class="number">12</span>],ID[<span class="number">12</span>:<span class="number">14</span>])</span><br><span class="line">    <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>
<br>
<h2 id="完整代码"><a class="markdownIt-Anchor" href="#完整代码"></a> 完整代码</h2>
<p>于是一个简易的身份证OCR工具就完成了。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># utils.py</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> shutil</span><br><span class="line"><span class="keyword">import</span> string</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line">DIFF_ANGLE = <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ==================== File Operations ====================</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">clear</span><span class="params">(PATH)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> os.path.exists(PATH):</span><br><span class="line">        shutil.rmtree(PATH)</span><br><span class="line">    os.mkdir(PATH)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">read_json</span><span class="params">(FILE)</span>:</span></span><br><span class="line">    <span class="keyword">with</span> open(FILE,encoding=<span class="string">'utf-8'</span>) <span class="keyword">as</span> f:</span><br><span class="line">        data = json.loads(f.read())</span><br><span class="line">    <span class="keyword">return</span> data</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">save_json</span><span class="params">(object,FILE)</span>:</span></span><br><span class="line">    <span class="keyword">with</span> open(FILE,<span class="string">"w"</span>) <span class="keyword">as</span> f:</span><br><span class="line">        json.dump(object,f,ensure_ascii=<span class="literal">False</span>,sort_keys=<span class="literal">True</span>,indent=<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># ====================    Geometry     ====================</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sqrdis</span><span class="params">(a,b)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> (a[<span class="number">0</span>]-b[<span class="number">0</span>])**<span class="number">2</span>+(a[<span class="number">1</span>]-b[<span class="number">1</span>])**<span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">product</span><span class="params">(a,b)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> a[<span class="number">0</span>]*b[<span class="number">1</span>]-a[<span class="number">1</span>]*b[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">angle</span><span class="params">(a)</span>:</span></span><br><span class="line">    r = math.degrees(math.atan2(a[<span class="number">1</span>],a[<span class="number">0</span>]))</span><br><span class="line">    <span class="keyword">if</span> r &gt; <span class="number">180</span>:</span><br><span class="line">        r -= <span class="number">180</span></span><br><span class="line">    <span class="keyword">if</span> r &lt; <span class="number">0</span>:</span><br><span class="line">        r += <span class="number">180</span></span><br><span class="line">    <span class="keyword">return</span> r</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">parallel</span><span class="params">(line1,line2)</span>:</span></span><br><span class="line">    a = np.array(line1[:<span class="number">2</span>],dtype=np.float32) - np.array(line1[<span class="number">2</span>:],dtype=np.float32)</span><br><span class="line">    b = np.array(line2[:<span class="number">2</span>],dtype=np.float32) - np.array(line2[<span class="number">2</span>:],dtype=np.float32)</span><br><span class="line">    diff = math.fabs(angle(a) - angle(b))</span><br><span class="line">    <span class="keyword">return</span> diff &lt;= DIFF_ANGLE <span class="keyword">or</span> diff &gt;= <span class="number">180</span>-DIFF_ANGLE</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cross</span><span class="params">(line1,line2)</span>:</span></span><br><span class="line">    a = np.array(line1[:<span class="number">2</span>],dtype=np.float32); b = np.array(line1[<span class="number">2</span>:],dtype=np.float32);</span><br><span class="line">    c = np.array(line2[:<span class="number">2</span>],dtype=np.float32); d = np.array(line2[<span class="number">2</span>:],dtype=np.float32)</span><br><span class="line">    <span class="keyword">return</span> a+(product(d-c,a-c)/product(b-a,d-c))*(b-a)</span><br><span class="line"></span><br><span class="line"><span class="comment"># ====================       OCR       ====================</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">rgb2grey</span><span class="params">(R,G,B)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> int(round(<span class="number">0.299</span>*R + <span class="number">0.587</span>*G + <span class="number">0.114</span>*B))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">clean</span><span class="params">(s)</span>:</span></span><br><span class="line">    <span class="keyword">return</span>(s.replace(<span class="string">" "</span>,<span class="string">""</span>)</span><br><span class="line">            .replace(<span class="string">"\r"</span>,<span class="string">""</span>)</span><br><span class="line">            .replace(<span class="string">"\n"</span>,<span class="string">""</span>)</span><br><span class="line">            .replace(<span class="string">"\t"</span>,<span class="string">""</span>)</span><br><span class="line">            .replace(<span class="string">"\f"</span>,<span class="string">""</span>)</span><br><span class="line">            .replace(<span class="string">"\v"</span>,<span class="string">""</span>))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">clean_num</span><span class="params">(s)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">''</span>.join(list(filter(str.isdigit,s)))</span><br><span class="line"></span><br><span class="line"><span class="comment"># ====================     ID Card     ====================</span></span><br><span class="line"></span><br><span class="line">ID_verify = [<span class="number">7</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">5</span>,<span class="number">8</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">6</span>,<span class="number">3</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">5</span>,<span class="number">8</span>,<span class="number">4</span>,<span class="number">2</span>]</span><br><span class="line">ID_table  = <span class="string">"10X98765432"</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">check_ID_simple</span><span class="params">(s)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> ID_table[np.dot(ID_verify,[int(j) <span class="keyword">for</span> j <span class="keyword">in</span> s[:<span class="number">17</span>]])%<span class="number">11</span>]==s[<span class="number">17</span>] <span class="keyword">if</span> len(s)==<span class="number">18</span> <span class="keyword">and</span> s[:<span class="number">17</span>].isdigit() <span class="keyword">and</span> (s[<span class="number">17</span>] <span class="keyword">in</span> ID_table) <span class="keyword">else</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">clean_ID</span><span class="params">(s)</span>:</span></span><br><span class="line">    s = <span class="string">''</span>.join(list(filter(<span class="keyword">lambda</span> x: x <span class="keyword">in</span> ID_table,s)))</span><br><span class="line">    <span class="keyword">if</span> s==<span class="string">""</span>:</span><br><span class="line">        <span class="keyword">return</span> s</span><br><span class="line">    n = len(s)<span class="number">-1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">''</span>.join(list(filter(str.isdigit,s[:n])))+s[n]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">clean_info</span><span class="params">(s)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">''</span>.join(list(filter(<span class="keyword">lambda</span> x: x <span class="keyword">not</span> <span class="keyword">in</span> string.punctuation,s)))</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># preprocess.py</span></span><br><span class="line"><span class="keyword">from</span> itertools <span class="keyword">import</span> permutations</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="keyword">import</span> PIL.ImageOps</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">from</span> utils <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">THRESH = <span class="number">165</span></span><br><span class="line">EDGE = <span class="number">10</span></span><br><span class="line">DIFF_SQRDIS = <span class="number">1000</span></span><br><span class="line">CANNY_LOW = <span class="number">150</span></span><br><span class="line">CANNY_HIGH = <span class="number">200</span></span><br><span class="line">HOUGH_THRESH = <span class="number">50</span></span><br><span class="line">HOUGH_MIN_LEN = <span class="number">100</span></span><br><span class="line">HOUGH_MAX_GAP = <span class="number">10</span></span><br><span class="line">LINES = <span class="number">20</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">opened</span><span class="params">(arr,invert=True)</span>:</span></span><br><span class="line">    blurred = cv2.GaussianBlur(arr,(<span class="number">9</span>,<span class="number">9</span>),<span class="number">0</span>)</span><br><span class="line">    _,binary = cv2.threshold(blurred,THRESH,<span class="number">255</span>,cv2.THRESH_BINARY)</span><br><span class="line">    kernel = cv2.getStructuringElement(cv2.MORPH_RECT,(<span class="number">5</span>,<span class="number">5</span>))</span><br><span class="line">    closed = cv2.morphologyEx(binary,cv2.MORPH_CLOSE,kernel)</span><br><span class="line">    result = cv2.morphologyEx(closed,cv2.MORPH_OPEN,kernel)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">255</span>-result <span class="keyword">if</span> invert <span class="keyword">else</span> result</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bounding_box</span><span class="params">(opened_arr)</span>:</span></span><br><span class="line">    contours,_ = cv2.findContours(opened_arr,cv2.RETR_LIST,cv2.CHAIN_APPROX_SIMPLE)</span><br><span class="line">    bounding_rect = cv2.minAreaRect(sorted(contours,key=cv2.contourArea,reverse=<span class="literal">True</span>)[<span class="number">1</span>])</span><br><span class="line">    <span class="keyword">return</span> np.int0(cv2.boxPoints(bounding_rect))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">crosses</span><span class="params">(lines,w,h)</span>:</span></span><br><span class="line">    points = []</span><br><span class="line">    unique_points = []</span><br><span class="line">    <span class="keyword">for</span> a <span class="keyword">in</span> lines:</span><br><span class="line">        <span class="keyword">for</span> b <span class="keyword">in</span> lines:</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> parallel(a,b):</span><br><span class="line">                p = cross(a,b)</span><br><span class="line">                <span class="keyword">if</span> -EDGE &lt;= p[<span class="number">0</span>] &lt;= w+EDGE <span class="keyword">and</span> -EDGE &lt;= p[<span class="number">1</span>] &lt;= h+EDGE:</span><br><span class="line">                    points.append(p)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(points)):</span><br><span class="line">        flag = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(i):</span><br><span class="line">            <span class="keyword">if</span> sqrdis(points[i],points[j]) &lt; DIFF_SQRDIS:</span><br><span class="line">                flag = <span class="literal">False</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">if</span> flag:</span><br><span class="line">            unique_points.append(points[i])</span><br><span class="line">    <span class="keyword">return</span> unique_points</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">matched</span><span class="params">(points)</span>:</span></span><br><span class="line">    <span class="keyword">assert</span>(len(points)==<span class="number">4</span>)</span><br><span class="line">    points = sorted(points,key=<span class="keyword">lambda</span> x:x[<span class="number">0</span>])</span><br><span class="line">    <span class="keyword">if</span> points[<span class="number">0</span>][<span class="number">1</span>] &gt; points[<span class="number">1</span>][<span class="number">1</span>]:</span><br><span class="line">        points[<span class="number">0</span>],points[<span class="number">1</span>] = points[<span class="number">1</span>],points[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">if</span> points[<span class="number">3</span>][<span class="number">1</span>] &gt; points[<span class="number">2</span>][<span class="number">1</span>]:</span><br><span class="line">        points[<span class="number">2</span>],points[<span class="number">3</span>] = points[<span class="number">3</span>],points[<span class="number">2</span>]</span><br><span class="line">    <span class="keyword">return</span> np.array(points,dtype=np.float32)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">affine</span><span class="params">(arr)</span>:</span></span><br><span class="line">    h,w = arr.shape</span><br><span class="line">    opened_arr = opened(arr)</span><br><span class="line">    box = bounding_box(opened_arr)</span><br><span class="line">    edges = cv2.Canny(opened_arr,CANNY_LOW,CANNY_HIGH,apertureSize=<span class="number">3</span>)</span><br><span class="line">    lines = cv2.HoughLinesP(edges, rho=<span class="number">1</span>, theta=np.pi/<span class="number">180</span>, threshold=HOUGH_THRESH, minLineLength=HOUGH_MIN_LEN, maxLineGap=HOUGH_MAX_GAP)</span><br><span class="line">    lines = sorted(lines,</span><br><span class="line">                   key=<span class="keyword">lambda</span> x:min([sqrdis(x[<span class="number">0</span>][:<span class="number">2</span>],box[<span class="number">0</span>])+sqrdis(x[<span class="number">0</span>][<span class="number">2</span>:],box[<span class="number">1</span>]),</span><br><span class="line">                                     sqrdis(x[<span class="number">0</span>][<span class="number">2</span>:],box[<span class="number">0</span>])+sqrdis(x[<span class="number">0</span>][:<span class="number">2</span>],box[<span class="number">1</span>]),</span><br><span class="line">                                     sqrdis(x[<span class="number">0</span>][:<span class="number">2</span>],box[<span class="number">1</span>])+sqrdis(x[<span class="number">0</span>][<span class="number">2</span>:],box[<span class="number">2</span>]),</span><br><span class="line">                                     sqrdis(x[<span class="number">0</span>][<span class="number">2</span>:],box[<span class="number">1</span>])+sqrdis(x[<span class="number">0</span>][:<span class="number">2</span>],box[<span class="number">2</span>]),</span><br><span class="line">                                     sqrdis(x[<span class="number">0</span>][:<span class="number">2</span>],box[<span class="number">2</span>])+sqrdis(x[<span class="number">0</span>][<span class="number">2</span>:],box[<span class="number">3</span>]),</span><br><span class="line">                                     sqrdis(x[<span class="number">0</span>][<span class="number">2</span>:],box[<span class="number">2</span>])+sqrdis(x[<span class="number">0</span>][:<span class="number">2</span>],box[<span class="number">3</span>]),</span><br><span class="line">                                     sqrdis(x[<span class="number">0</span>][:<span class="number">2</span>],box[<span class="number">3</span>])+sqrdis(x[<span class="number">0</span>][<span class="number">2</span>:],box[<span class="number">0</span>]),</span><br><span class="line">                                     sqrdis(x[<span class="number">0</span>][<span class="number">2</span>:],box[<span class="number">3</span>])+sqrdis(x[<span class="number">0</span>][:<span class="number">2</span>],box[<span class="number">0</span>])</span><br><span class="line">                                   ]),</span><br><span class="line">                   reverse=<span class="literal">False</span>)</span><br><span class="line">    lines = [np.array(x[<span class="number">0</span>],dtype=np.float32) <span class="keyword">for</span> x <span class="keyword">in</span> lines[:LINES]]</span><br><span class="line">    points = crosses(lines,w,h)</span><br><span class="line">    <span class="comment"># blank = arr</span></span><br><span class="line">    <span class="comment"># for j in lines:</span></span><br><span class="line">    <span class="comment">#     cv2.line(blank,(j[0],j[1]),(j[2],j[3]),0,10)</span></span><br><span class="line">    <span class="comment"># for j in points:</span></span><br><span class="line">    <span class="comment">#     cv2.circle(blank,(j[0],j[1]),10,0,-1)</span></span><br><span class="line">    <span class="comment"># cv2.imshow("img",blank)</span></span><br><span class="line">    <span class="comment"># cv2.waitKey(0)</span></span><br><span class="line">    <span class="keyword">return</span> cv2.getPerspectiveTransform(matched(points),np.array([[<span class="number">0</span>,<span class="number">0</span>],[<span class="number">0</span>,h],[w,h],[w,<span class="number">0</span>]],dtype=np.float32))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">align</span><span class="params">(img)</span>:</span></span><br><span class="line">    arr = np.array(img.copy().convert(<span class="string">'L'</span>))</span><br><span class="line">    h,w = arr.shape</span><br><span class="line">    transform = affine(arr)</span><br><span class="line">    arr = cv2.warpPerspective(np.array(img),transform,(w,h))</span><br><span class="line">    <span class="keyword">return</span> Image.fromarray(arr)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">normalized</span><span class="params">(img)</span>:</span></span><br><span class="line">    arr = np.array(img.copy().convert(<span class="string">'L'</span>))</span><br><span class="line">    arr_min = arr.min()</span><br><span class="line">    arr_max = arr.max()</span><br><span class="line">    arr = ((arr-arr_min)/(arr_max-arr_min)*<span class="number">255</span>).astype(np.uint8)</span><br><span class="line">    <span class="keyword">return</span> Image.fromarray(arr)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># OCR.py</span></span><br><span class="line"><span class="keyword">from</span> copy <span class="keyword">import</span> deepcopy</span><br><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line"><span class="keyword">import</span> imutils</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> preprocess <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">src = <span class="string">"images/"</span></span><br><span class="line">tmp = <span class="string">"temp/"</span></span><br><span class="line">dst = <span class="string">"processed/"</span></span><br><span class="line">rst = <span class="string">"results/"</span></span><br><span class="line">CHINESE = (</span><br><span class="line">          <span class="comment"># "chi_sim_2412"</span></span><br><span class="line">          <span class="comment"># "chi_sim_12771"</span></span><br><span class="line">           <span class="string">"chi_sim_43327"</span></span><br><span class="line">          )</span><br><span class="line">LAN = &#123;<span class="string">'Z'</span>:<span class="string">"-l "</span>+CHINESE,<span class="string">'N'</span>:<span class="string">""</span>,<span class="string">'E'</span>:<span class="string">""</span>&#125;</span><br><span class="line">config = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">make_environment</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">global</span> config</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(src):</span><br><span class="line">        os.mkdir(src)</span><br><span class="line">    clear(tmp)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(dst):</span><br><span class="line">        os.mkdir(dst)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(rst):</span><br><span class="line">        os.mkdir(rst)</span><br><span class="line">    config = read_json(<span class="string">"config.json"</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">tesseract</span><span class="params">(FILE,TYPE,RESULT)</span>:</span></span><br><span class="line">    command = <span class="string">'tesseract &#123;0&#125; &#123;1&#125; &#123;2&#125;'</span>.format(LAN[TYPE],FILE,RESULT)</span><br><span class="line">    <span class="keyword">return</span> subprocess.Popen(command,shell=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">OCR</span><span class="params">(PIC_NAME,move=False,delete=False)</span>:</span></span><br><span class="line">    PATH = src+PIC_NAME</span><br><span class="line">    category = (deepcopy(config[PIC_NAME[:<span class="number">2</span>]]) <span class="keyword">if</span> PIC_NAME[:<span class="number">2</span>] <span class="keyword">in</span> config <span class="keyword">else</span> &#123;<span class="string">'info'</span>:&#123;<span class="string">'Z0'</span>:[<span class="number">0.</span>,<span class="number">0.</span>,<span class="number">1.</span>,<span class="number">1.</span>]&#125;&#125;)[<span class="string">'info'</span>]</span><br><span class="line">    result = &#123;&#125;</span><br><span class="line">    thread = &#123;&#125;</span><br><span class="line">    <span class="keyword">with</span> Image.open(PATH) <span class="keyword">as</span> img:</span><br><span class="line">        w,h = img.size</span><br><span class="line">        <span class="keyword">for</span> key,box <span class="keyword">in</span> category.items():</span><br><span class="line">            TEMP = tmp+key+<span class="string">"_"</span>+PIC_NAME</span><br><span class="line">            RESULT = tmp+key+<span class="string">"_"</span>+PIC_NAME.split(<span class="string">'.'</span>)[<span class="number">0</span>]</span><br><span class="line">            box[<span class="number">0</span>] *= w; box[<span class="number">1</span>] *= h; box[<span class="number">2</span>] *= w; box[<span class="number">3</span>] *= h</span><br><span class="line">            img_cr = img.crop([int(round(j)) <span class="keyword">for</span> j <span class="keyword">in</span> box])</span><br><span class="line">            <span class="comment"># img_cr.show()</span></span><br><span class="line">            <span class="keyword">if</span> key[<span class="number">0</span>]==<span class="string">'M'</span>:</span><br><span class="line">                img_cr.save(rst+key[<span class="number">1</span>:]+<span class="string">"_"</span>+PIC_NAME)</span><br><span class="line">                result[key] = key[<span class="number">1</span>:]+<span class="string">"_"</span>+PIC_NAME</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                img_cr = normalized(img_cr)</span><br><span class="line">                img_cr.save(TEMP,dpi=(<span class="number">300.0</span>,<span class="number">300.0</span>))</span><br><span class="line">                thread[key] = tesseract(TEMP,key[<span class="number">0</span>],RESULT)</span><br><span class="line">        <span class="keyword">for</span> key,box <span class="keyword">in</span> category.items():</span><br><span class="line">            <span class="keyword">if</span> key[<span class="number">0</span>]==<span class="string">'M'</span>:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            TEMP = tmp+key+<span class="string">"_"</span>+PIC_NAME</span><br><span class="line">            RESULT = tmp+key+<span class="string">"_"</span>+PIC_NAME.split(<span class="string">'.'</span>)[<span class="number">0</span>]+<span class="string">".txt"</span></span><br><span class="line">            thread[key].wait()</span><br><span class="line">            <span class="keyword">with</span> open(RESULT,<span class="string">"r"</span>,encoding=<span class="string">'UTF-8'</span>) <span class="keyword">as</span> f:</span><br><span class="line">                result[key] = clean(f.read())</span><br><span class="line">            <span class="keyword">if</span> key[<span class="number">0</span>]==<span class="string">'N'</span>:</span><br><span class="line">                result[key] = clean_num(result[key])</span><br><span class="line">    <span class="keyword">if</span> move:</span><br><span class="line">        <span class="keyword">with</span> Image.open(PATH) <span class="keyword">as</span> img:</span><br><span class="line">            img.save(dst+PIC_NAME)</span><br><span class="line">    <span class="keyword">if</span> delete:</span><br><span class="line">        os.remove(PATH)</span><br><span class="line">    clear(tmp)</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">ID_Card_OCR</span><span class="params">(PIC_NAME)</span>:</span></span><br><span class="line">    <span class="keyword">assert</span>(PIC_NAME[:<span class="number">2</span>]==<span class="string">"sf"</span> <span class="keyword">and</span> <span class="string">"sf"</span> <span class="keyword">in</span> config)</span><br><span class="line">    PATH = src+PIC_NAME</span><br><span class="line">    ID_PIC = <span class="string">"id"</span>+PIC_NAME[<span class="number">2</span>:]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">with</span> Image.open(PATH) <span class="keyword">as</span> img:</span><br><span class="line">        w,h = img.size</span><br><span class="line">        <span class="keyword">if</span> w &lt; h:</span><br><span class="line">            img = img.transpose(Image.ROTATE_90); w,h = h,w</span><br><span class="line">        img.save(PATH,dpi=(<span class="number">300.0</span>,<span class="number">300.0</span>))</span><br><span class="line">        img.save(src+ID_PIC,dpi=(<span class="number">300.0</span>,<span class="number">300.0</span>))</span><br><span class="line">    </span><br><span class="line">    ID = clean_ID(OCR(ID_PIC,delete=<span class="literal">True</span>)[<span class="string">'Eid'</span>])</span><br><span class="line">    <span class="keyword">if</span> check_ID_simple(ID):</span><br><span class="line">        result = OCR(PIC_NAME)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">with</span> Image.open(PATH) <span class="keyword">as</span> img:</span><br><span class="line">            img = align(img)</span><br><span class="line">            w,h = img.size</span><br><span class="line">            w = int(h * config[PIC_NAME[:<span class="number">2</span>]][<span class="string">'ratio'</span>])</span><br><span class="line">            img = img.resize((w,h),Image.ANTIALIAS)</span><br><span class="line">            <span class="comment"># img.show()</span></span><br><span class="line">            <span class="comment"># exit(0)</span></span><br><span class="line">            img.save(PATH,dpi=(<span class="number">300.0</span>,<span class="number">300.0</span>))</span><br><span class="line">        result = OCR(PIC_NAME)</span><br><span class="line">        ID = clean_ID(result[<span class="string">'Eid'</span>])</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> check_ID_simple(ID):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">    result[<span class="string">'id'</span>] = ID</span><br><span class="line">    result[<span class="string">'picture'</span>] = result[<span class="string">'Mpicture'</span>]</span><br><span class="line">    result[<span class="string">'name'</span>] = clean_info(result[<span class="string">'Zname'</span>])</span><br><span class="line">    result[<span class="string">'address'</span>] = clean_info(result[<span class="string">'Zaddress'</span>])</span><br><span class="line">    <span class="keyword">del</span> result[<span class="string">'Eid'</span>],result[<span class="string">'Mpicture'</span>],result[<span class="string">'Zname'</span>],result[<span class="string">'Zaddress'</span>]</span><br><span class="line">    result[<span class="string">'sex'</span>] = <span class="string">"男"</span> <span class="keyword">if</span> int(ID[<span class="number">16</span>])%<span class="number">2</span> <span class="keyword">else</span> <span class="string">"女"</span></span><br><span class="line">    result[<span class="string">'birthdate'</span>] = <span class="string">"&#123;0&#125;年&#123;1&#125;月&#123;2&#125;日"</span>.format(ID[<span class="number">6</span>:<span class="number">10</span>],ID[<span class="number">10</span>:<span class="number">12</span>],ID[<span class="number">12</span>:<span class="number">14</span>])</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line">make_environment()</span><br><span class="line">print(ID_Card_OCR(<span class="string">"sf1.jpg"</span>))</span><br></pre></td></tr></table></figure>
<p>识别结果(<code>已和谐</code>的识别完全正确，需要提醒一点，这个识别工具准确率很依赖于照片环境，不能保证一直高正确率):</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&apos;id&apos;: 已和谐, &apos;picture&apos;: &apos;picture_sf8.jpg&apos;, &apos;name&apos;: &apos;陈醉&apos;, &apos;address&apos;: 已和谐, &apos;sex&apos;: &apos;男&apos;, &apos;birthdate&apos;: &apos;2001年08月18日&apos;&#125;</span><br></pre></td></tr></table></figure>
<p>完结撒花！！！</p>
<p><img src="/img/2020-02-13-blog-01/wjsh.jpg" alt></p>
<br>
<blockquote>
<p>扫描二维码即可在手机上查看这篇文章，或者转发二维码来分享这篇文章:</p>
</blockquote>
<p><img src="/img/2020-02-13-blog-01/QR_code.png" alt></p>
<br></div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined" rel="external nofollow noopener noreferrer" target="_blank">Magolor</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://magolor.cn/2020/02/13/2020-02-13-blog-01/">https://magolor.cn/2020/02/13/2020-02-13-blog-01/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="external nofollow noopener noreferrer" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://magolor.cn">Magolor</a>！</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/图像处理/">图像处理</a><a class="post-meta__tags" href="/tags/OCR/">OCR</a></div><div class="post-qr-code"><div class="post-qr-code-item"><img class="post-qr-code__img" src="/img/Magolor.png"><div class="post-qr-code__desc">扫描二维码在手机上查看或转发二维码以分享Magolor的博客</div></div></div><div class="addthis_inline_share_toolbox pull-right"></div><script src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5c4b07a2561d21f6" async></script><nav id="pagination"><div class="prev-post pull-left"><a href="/2020/04/02/2020-04-02-blog-01/"><i class="fa fa-chevron-left">  </i><span>Codeforces April Fools Day Contest 2020 做题题解</span></a></div><div class="next-post pull-right"><a href="/2020/01/14/2020-01-14-blog-01/"><span>PyTorch入门: Kaggle 猫狗识别VGG</span><i class="fa fa-chevron-right"></i></a></div></nav><div class="post-adv"><center><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="530" height="86" src="//music.163.com/outchain/player?type=2&id=1498842614&auto=0&height=66"></iframe></center></div><div id="gitalk-container"></div><script>var gitalk = new Gitalk({
  clientID: '60134c8112d0936f31e1',
  clientSecret: '0e44267dd38cbf3d995de5ed11a897b6385aff55',
  repo: 'magolor.github.io',
  owner: 'Magolor',
  admin: 'Magolor',
  id: md5(decodeURI(location.pathname)),
  language: 'zh-CN'
})
gitalk.render('gitalk-container')</script></div></div><footer class="footer-bg" style="background-image: url(/img/Beneath_the_Starlight_16-9.png)"><div class="layout" id="footer"><div class="copyright">&copy;2018 - 2020 By Magolor</div><div class="framework-info"><span>驱动 - </span><a href="http://hexo.io" rel="external nofollow noopener noreferrer" target="_blank"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody" rel="external nofollow noopener noreferrer" target="_blank"><span>Melody</span></a></div><div class="footer_custom_text">Fate is Fluid, Destiny is in the hands of Man.</div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.7.0"></script><script src="/js/fancybox.js?version=1.7.0"></script><script src="/js/sidebar.js?version=1.7.0"></script><script src="/js/copy.js?version=1.7.0"></script><script src="/js/fireworks.js?version=1.7.0"></script><script src="/js/transition.js?version=1.7.0"></script><script src="/js/scroll.js?version=1.7.0"></script><script src="/js/head.js?version=1.7.0"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.css"><script src="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.css"><script src="/js/katex.js"></script><script src="/js/search/local-search.js"></script><script id="ribbon" src="/js/third-party/canvas-ribbon.js" size="250" alpha="0.3" zindex="-2" data-click="false"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章"></div></div></div><hr><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>由</span> <a href="https://github.com/wzpan/hexo-generator-search" style="color:#49B1F5;" rel="external nofollow noopener noreferrer" target="_blank">hexo-generator-search</a>
 <span>提供支持</span></div></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div><!-- hexo-inject:begin --><!-- hexo-inject:end --><script async>window.onload=function(){var a=document.createElement('script'),b=document.getElementsByTagName('script')[0];a.type='text/javascript',a.async=!0,a.src='/sw-register.js?v='+Date.now(),b.parentNode.insertBefore(a,b)};</script></body></html>